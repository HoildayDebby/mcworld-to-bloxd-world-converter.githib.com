<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Minecraft → Bloxd Converter</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body{font-family:system-ui,Arial;max-width:820px;margin:2rem auto;padding:0 1rem;}
.drop{border:3px dashed #999;border-radius:12px;padding:40px;text-align:center;transition:.2s;cursor:pointer;}
.drop.dragover{border-color:#4caf50;background:#eaffea;}
button{padding:.6rem 1rem;margin:.3rem;cursor:pointer;}
pre{background:#f6f6f6;padding:.75rem;border-radius:6px;overflow:auto;}
</style>
</head>
<body>
<h1>Minecraft World → Bloxd Schematic Converter</h1>
<p>Drop a <b>.mcworld</b>, <b>.schem</b>, <b>.schematic</b>, or <b>.litematic</b> file below.<br>
Converts Minecraft world blocks or schematics into <code>.bloxdschem</code> for Bloxd.io.</p>

<div id="drop" class="drop">
<p>Drop your file here<br>or click to pick</p>
<input id="file" type="file" hidden />
<div id="status"></div>
<div id="actions"></div>
</div>

<script src="vendor/jszip.min.js"></script>
<script src="vendor/m2b.js"></script>
<script src="vendor/nbt.js"></script> <!-- NBT parser -->

<script>
const drop = document.getElementById("drop");
const fileInput = document.getElementById("file");
const status = document.getElementById("status");
const actions = document.getElementById("actions");

function setStatus(t){status.textContent=t;}
function clearActions(){actions.innerHTML="";}

// Drag & Drop
drop.addEventListener("click",()=>fileInput.click());
drop.addEventListener("dragover",e=>{e.preventDefault();drop.classList.add("dragover");});
drop.addEventListener("dragleave",()=>drop.classList.remove("dragover"));
drop.addEventListener("drop",e=>{
  e.preventDefault(); drop.classList.remove("dragover");
  const f = e.dataTransfer.files[0];
  if(!f) return;
  fileInput.files = e.dataTransfer.files;
  fileInput.dispatchEvent(new Event("change"));
});

// File selection
fileInput.addEventListener("change", async(ev)=>{
  clearActions();
  const f = ev.target.files[0];
  if(!f) return;
  const name = f.name.toLowerCase();
  setStatus("Processing: "+f.name);

  if(name.endsWith(".schem")||name.endsWith(".schematic")||name.endsWith(".litematic")){
    convertWithM2B(f);
  } else if(name.endsWith(".mcworld")){
    await handleMcworld(f);
  } else {
    setStatus("Unsupported file type.");
  }
});

// Convert schematic files
async function convertWithM2B(blob){
  try{
    setStatus("Converting → .bloxdschem ...");
    const result = await m2b.convertFile(blob);
    downloadBlob(result.blob, result.filename);
    setStatus("Done! File downloaded.");
  }catch(e){setStatus("Conversion failed: "+e);}
}

// Handle .mcworld
async function handleMcworld(f){
  try{
    const buf = await f.arrayBuffer();
    const zip = await JSZip.loadAsync(buf);

    const isJava = Object.keys(zip.files).some(p=>p.startsWith("region/"));
    const isBedrock = Object.keys(zip.files).some(p=>p.startsWith("db/"));

    if(isJava){
      convertJavaMcworld(zip);
    } else if(isBedrock){
      await handleBedrockMcworld(zip);
    } else {
      setStatus("No recognizable world data found.");
    }

  }catch(e){
    setStatus("Error reading .mcworld: "+e);
  }
}

// Convert Java .mcworld
async function convertJavaMcworld(zip){
  try{
    setStatus("Java .mcworld detected. Parsing region files...");

    const regionFiles = Object.keys(zip.files).filter(p=>p.startsWith("region/") && p.endsWith(".mca"));
    if(regionFiles.length===0){
      setStatus("No region files found.");
      return;
    }

    let tempSchematic = {width:0,height:0,length:0,blocks:[],palette:{}};

    for(const rFile of regionFiles){
      const data = await zip.files[rFile].async("arrayBuffer");

      // TODO: implement parseMCAtoChunks using nbt.js
      const chunks = parseMCAtoChunks(data); // return array of {chunkX, chunkZ, blocks:[{x,y,z,id}]}

      for(const chunk of chunks){
        for(const block of chunk.blocks){
          tempSchematic.blocks.push({
            x: block.x + chunk.chunkX*16,
            y: block.y,
            z: block.z + chunk.chunkZ*16,
            name: block.id
          });
          tempSchematic.width = Math.max(tempSchematic.width, block.x + chunk.chunkX*16 +1);
          tempSchematic.height = Math.max(tempSchematic.height, block.y+1);
          tempSchematic.length = Math.max(tempSchematic.length, block.z + chunk.chunkZ*16 +1);
        }
      }
    }

    setStatus("Building Bloxd.io schematic...");
    const result = await m2b.convertSchematicObject(tempSchematic);
    downloadBlob(result.blob, "world.bloxdschem");
    setStatus("Done! Bloxd.io schematic ready.");

  }catch(e){
    setStatus("Error converting Java .mcworld: "+e);
  }
}

// Handle Bedrock .mcworld
async function handleBedrockMcworld(zip){
  // find any schematics inside the ZIP
  const schematicFiles = Object.keys(zip.files).filter(p =>
    p.endsWith(".schem") || p.endsWith(".schematic") || p.endsWith(".litematic")
  );

  if(schematicFiles.length === 0){
    setStatus("No schematics found inside Bedrock world. Please export builds first.");
    return;
  }

  setStatus(`Found ${schematicFiles.length} schematic(s). Converting...`);

  for(const path of schematicFiles){
    const fileData = await zip.files[path].async("blob");
    try{
      const result = await m2b.convertFile(fileData);
      downloadBlob(result.blob, result.filename);
    }catch(e){
      console.error("Conversion failed for", path, e);
    }
  }

  setStatus("All schematics converted to Bloxd.io!");
}

// Download helper
function downloadBlob(blob, filename="output.bloxdschem"){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

</script>
</body>
</html>
