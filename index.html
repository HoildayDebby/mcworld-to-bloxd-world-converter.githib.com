<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Minecraft → Bloxd Converter</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body{font-family:system-ui,Arial;max-width:820px;margin:2rem auto;padding:0 1rem;}
.drop{border:3px dashed #999;border-radius:12px;padding:40px;text-align:center;transition:.2s;cursor:pointer;}
.drop.dragover{border-color:#4caf50;background:#eaffea;}
button{padding:.6rem 1rem;margin:.3rem;cursor:pointer;}
pre{background:#f6f6f6;padding:.75rem;border-radius:6px;overflow:auto;}
</style>
</head>
<body>
<h1>Minecraft World → Bloxd Schematic Converter</h1>
<p>Drop a <b>.mcworld</b> (Java or Bedrock), a Java world folder, or a schematic file (.schem/.litematic/.schematic) below.<br>
Java worlds will be converted to a schematic first, then into <code>.bloxdschem</code>. <br>
Bedrock worlds/folders must be exported as schematics first.</p>

<div id="drop" class="drop">
<p>Drop your file or folder here<br>or click to pick</p>
<input id="file" type="file" hidden webkitdirectory directory multiple />
<div id="status"></div>
<div id="actions"></div>
</div>

<script src="vendor/jszip.min.js"></script>
<script src="vendor/m2b.js"></script>
<script src="vendor/nbt.js"></script>

<script>
const drop = document.getElementById("drop");
const fileInput = document.getElementById("file");
const status = document.getElementById("status");
const actions = document.getElementById("actions");

function setStatus(msg){ status.textContent = msg; }
function clearActions(){ actions.innerHTML = ""; }

drop.addEventListener("click",()=>fileInput.click());
drop.addEventListener("dragover",e=>{ e.preventDefault(); drop.classList.add("dragover"); });
drop.addEventListener("dragleave",()=>drop.classList.remove("dragover"));
drop.addEventListener("drop", e=>{
    e.preventDefault();
    drop.classList.remove("dragover");
    const files = e.dataTransfer.files;
    if(files.length===0) return;
    fileInput.files = files;
    fileInput.dispatchEvent(new Event("change"));
});

fileInput.addEventListener("change", async(e)=>{
    clearActions();
    const files = Array.from(e.target.files);
    if(files.length===0) return;

    setStatus("Processing files...");

    // Check for standalone schematics
    const schemFile = files.find(f=>f.name.toLowerCase().match(/\.(schem|schematic|litematic)$/));
    if(schemFile){
        await convertSchemToBloxd(schemFile);
        return;
    }

    // Check for Java folder
    const hasRegion = files.some(f=>f.webkitRelativePath.startsWith("region/") && f.name.endsWith(".mca"));
    const hasDB = files.some(f=>f.webkitRelativePath.startsWith("db/"));
    const hasManifest = files.some(f=>f.name==="manifest.json");

    if(hasRegion){
        await convertJavaFolder(files);
    } else if(hasDB && hasManifest){
        setStatus("Bedrock world detected. Full world conversion not supported in-browser. Export build as .schem first.");
    } else {
        // If it is a zip file, try to open as Java .mcworld zip
        const zipFile = files.find(f=>f.name.toLowerCase().endsWith(".mcworld"));
        if(zipFile){
            await handleMcworld(zipFile);
        } else {
            setStatus("No recognizable world data found.");
        }
    }
});

// Convert schematic files
async function convertSchemToBloxd(file){
    setStatus("Converting schematic → Bloxd...");
    try{
        const result = await m2b.convertFile(file);
        downloadBlob(result.blob, result.filename);
        setStatus("Done! Bloxd schematic downloaded.");
    }catch(e){
        setStatus("Conversion failed: "+e);
    }
}

// Convert Java folder with region files
async function convertJavaFolder(files){
    setStatus("Java folder detected. Reading region files...");

    const regionFiles = files.filter(f => f.webkitRelativePath.startsWith("region/") && f.name.endsWith(".mca"));
    if(regionFiles.length===0){
        setStatus("No region files found. Cannot convert.");
        return;
    }

    let tempSchem = {width:0,height:0,length:0,blocks:[],palette:{}};

    for(let i=0;i<regionFiles.length;i++){
        setStatus(`Parsing region ${i+1}/${regionFiles.length}`);
        const file = regionFiles[i];
        const buf = await file.arrayBuffer();
        const chunks = parseMCAtoChunks(buf); // Implement MCA parser
        for(const chunk of chunks){
            for(const block of chunk.blocks){
                tempSchem.blocks.push({
                    x:block.x + chunk.chunkX*16,
                    y:block.y,
                    z:block.z + chunk.chunkZ*16,
                    name:block.id
                });
                tempSchem.width = Math.max(tempSchem.width, block.x + chunk.chunkX*16 + 1);
                tempSchem.height = Math.max(tempSchem.height, block.y + 1);
                tempSchem.length = Math.max(tempSchem.length, block.z + chunk.chunkZ*16 + 1);
            }
        }
    }

    setStatus("Converting extracted blocks → Bloxd schematic...");
    const result = await m2b.convertSchematicObject(tempSchem);
    downloadBlob(result.blob, "world.bloxdschem");
    setStatus("Done! Bloxd schematic ready.");
}

// Handle Java .mcworld zip
async function handleMcworld(f){
    const buf = await f.arrayBuffer();
    const zip = await JSZip.loadAsync(buf);

    const isJava = Object.keys(zip.files).some(p => p.startsWith("region/") && p.endsWith(".mca"));
    const isBedrock = Object.keys(zip.files).some(p => p.startsWith("db/")) && Object.keys(zip.files).some(p => p === "manifest.json");

    if(isJava){
        await convertJavaZip(zip);
    } else if(isBedrock){
        setStatus("Bedrock .mcworld detected. Full world conversion is not supported in-browser. Please export your build as a .schem first to convert.");
    } else {
        setStatus("No recognizable world data found.");
    }
}

// Convert Java zip
async function convertJavaZip(zip){
    setStatus("Java .mcworld detected. Extracting region files...");
    const regionFiles = Object.keys(zip.files).filter(p=>p.startsWith("region/") && p.endsWith(".mca"));
    if(regionFiles.length===0){
        setStatus("No region files found. Cannot convert.");
        return;
    }

    let tempSchem = {width:0,height:0,length:0,blocks:[],palette:{}};

    for(let i=0;i<regionFiles.length;i++){
        setStatus(`Parsing region ${i+1}/${regionFiles.length}`);
        const data = await zip.files[regionFiles[i]].async("arrayBuffer");
        const chunks = parseMCAtoChunks(data); // Implement MCA parser
        for(const chunk of chunks){
            for(const block of chunk.blocks){
                tempSchem.blocks.push({
                    x:block.x + chunk.chunkX*16,
                    y:block.y,
                    z:block.z + chunk.chunkZ*16,
                    name:block.id
                });
                tempSchem.width = Math.max(tempSchem.width, block.x + chunk.chunkX*16 + 1);
                tempSchem.height = Math.max(tempSchem.height, block.y + 1);
                tempSchem.length = Math.max(tempSchem.length, block.z + chunk.chunkZ*16 + 1);
            }
        }
    }

    setStatus("Converting extracted blocks → Bloxd schematic...");
    const result = await m2b.convertSchematicObject(tempSchem);
    downloadBlob(result.blob, "world.bloxdschem");
    setStatus("Done! Bloxd schematic ready.");
}

// Download helper
function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}

// Placeholder for MCA parsing
function parseMCAtoChunks(arrayBuffer){
    // Implement actual MCA parsing using NBT.js
    return [];
}
</script>
</body>
</html>
